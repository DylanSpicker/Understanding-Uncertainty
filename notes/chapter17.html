<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>17&nbsp; Nonparametric Hypothesis Testing â€“ Understanding Uncertainty</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notes/chapter18.html" rel="next">
<link href="../notes/chapter16.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9e10166b8cbf4a4130f8224f3febb104.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/editor/editor.main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer">
  
<style type="text/css">.monaco-editor pre {
  background-color: unset !important;
}

.qwebr-icon-status-spinner {
  color: #7894c4;
}

.qwebr-icon-run-code {
  color: #0d9c29
}

.qwebr-output-code-stdout {
  color: #111;
}

.qwebr-output-code-stderr {
  color: #db4133;
}

.qwebr-editor {
  border: 1px solid #EEEEEE;
}

.qwebr-button-run {
  background-color: #EEEEEE;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0; /* Extra styling for consistency */
  display: inline-block;
  font-weight: 400;
  line-height: 1.5;
  color: #000;
  text-align: center;
  text-decoration: none;
  -webkit-text-decoration: none;
  -moz-text-decoration: none;
  -ms-text-decoration: none;
  -o-text-decoration: none;
  /* vertical-align: middle; */ /* Prevents a space from appearing between the code cell and button */
  -webkit-user-select: none;
  border-color: #dee2e6;
  border: 1px solid rgba(0,0,0,0);
  padding: 0.375rem 0.75rem;
  font-size: 1rem;
  border-top-right-radius: 0.25rem;
  border-top-left-radius: 0.25rem;
  transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}

.qwebr-button-run:hover {
  color: #000;
  background-color: #e3e6ea;
  border-color: #e1e5e9;
}

.qwebr-button-run:disabled,.qwebr-button-run.disabled,fieldset:disabled .qwebr-button-run {
  pointer-events: none;
  opacity: .65
}

/* Custom styling for RevealJS Presentations*/

/* Reset the style of the interactive area */
.reveal div.qwebr-interactive-area {
  display: block;
  box-shadow: none;
  max-width: 100%;
  max-height: 100%;
  margin: 0;
  padding: 0;
} 

/* Provide space to entries */
.reveal div.qwebr-output-code-area pre div {
  margin: 1px 2px 1px 10px;
}

/* Collapse the inside code tags to avoid extra space between line outputs */
.reveal pre div code.qwebr-output-code-stdout, .reveal pre div code.qwebr-output-code-stderr {
  padding: 0;
  display: contents;
}

.reveal pre div code.qwebr-output-code-stdout {
  color: #111;
}

.reveal pre div code.qwebr-output-code-stderr {
  color: #db4133;
}


/* Create a border around console and output (does not effect graphs) */
.reveal div.qwebr-console-area {
  border: 1px solid #EEEEEE;
  box-shadow: 2px 2px 10px #EEEEEE;
}

/* Cap output height and allow text to scroll */
/* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
.reveal div.qwebr-output-code-area pre {
  max-height: 400px;
  overflow: scroll;
}
</style>
<script type="module">// Start a timer
const initializeWebRTimerStart = performance.now();

// Determine if we need to install R packages
var installRPackagesList = [''];
// Check to see if we have an empty array, if we do set to skip the installation.
var setupRPackages = !(installRPackagesList.indexOf("") !== -1);
var autoloadRPackages = true;

// Display a startup message?
var showStartupMessage = true;
var showHeaderMessage = false;
if (showStartupMessage) {

  // Get references to header elements
  const headerHTML = document.getElementById("title-block-header");
  const headerRevealJS = document.getElementById("title-slide");

  // Create the outermost div element for metadata
  const quartoTitleMeta = document.createElement("div");
  quartoTitleMeta.classList.add("quarto-title-meta");

  // Create the first inner div element
  const firstInnerDiv = document.createElement("div");
  firstInnerDiv.setAttribute("id", "qwebr-status-message-area");

  // Create the second inner div element for "WebR Status" heading and contents
  const secondInnerDiv = document.createElement("div");
  secondInnerDiv.setAttribute("id", "qwebr-status-message-title");
  secondInnerDiv.classList.add("quarto-title-meta-heading");
  secondInnerDiv.innerText = "WebR Status";

  // Create another inner div for contents
  const secondInnerDivContents = document.createElement("div");
  secondInnerDivContents.setAttribute("id", "qwebr-status-message-body");
  secondInnerDivContents.classList.add("quarto-title-meta-contents");

  // Describe the WebR state
  var startupMessageWebR = document.createElement("p");
  startupMessageWebR.innerText = "ðŸŸ¡ Loading...";
  startupMessageWebR.setAttribute("id", "qwebr-status-message-text");
  // Add `aria-live` to auto-announce the startup status to screen readers
  startupMessageWebR.setAttribute("aria-live", "assertive");

  // Append the startup message to the contents
  secondInnerDivContents.appendChild(startupMessageWebR);

  // Add a status indicator for COOP and COEP Headers if needed
  if (showHeaderMessage) {
    const crossOriginMessage = document.createElement("p");
    crossOriginMessage.innerText = `${crossOriginIsolated ? 'ðŸŸ¢' : 'ðŸŸ¡'} COOP & COEP Headers`;
    crossOriginMessage.setAttribute("id", "qwebr-coop-coep-header");
    secondInnerDivContents.appendChild(crossOriginMessage);
  }

  // Combine the inner divs and contents
  firstInnerDiv.appendChild(secondInnerDiv);
  firstInnerDiv.appendChild(secondInnerDivContents);
  quartoTitleMeta.appendChild(firstInnerDiv);

  // Determine where to insert the quartoTitleMeta element
  if (headerHTML) {
    // Append to the existing "title-block-header" element
    headerHTML.appendChild(quartoTitleMeta);
  } else if (headerRevealJS) {
    // If using RevealJS, add to the "title-slide" div
    headerRevealJS.appendChild(firstInnerDiv);
  } else {
    // If neither headerHTML nor headerRevealJS is found, insert after "webr-monaco-editor-init" script
    const monacoScript = document.getElementById("qwebr-monaco-editor-init");
    const header = document.createElement("header");
    header.setAttribute("id", "title-block-header");
    header.appendChild(quartoTitleMeta);
    monacoScript.after(header);
  }
}

// Retrieve the webr.mjs
import { WebR, ChannelType } from "https://webr.r-wasm.org/v0.2.2/webr.mjs";

// Populate WebR options with defaults or new values based on 
// webr meta
globalThis.webR = new WebR({
  "baseURL": "https://webr.r-wasm.org/v0.2.2/",
  "serviceWorkerUrl": "",
  "homedir": "/home/web_user", 
  "channelType": ChannelType.Automatic
});

// Initialization WebR
await webR.init();

// Setup a shelter
globalThis.webRCodeShelter = await new webR.Shelter();

// Setup a pager to allow processing help documentation 
await webR.evalRVoid('webr::pager_install()'); 

// Function to set the button text
function qwebrSetInteractiveButtonState(buttonText, enableCodeButton = true) {
  document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
    btn.innerHTML = buttonText;
    btn.disabled = !enableCodeButton;
  });
}

// Function to update the status message
function qwebrUpdateStatusHeader(message) {
  startupMessageWebR.innerHTML = `
    <i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i>
    <span>${message}</span>`;
}

// Function to install a single package
async function qwebrInstallRPackage(packageName) {
  await globalThis.webR.installPackages([packageName]);
}

// Function to load a single package
async function qwebrLoadRPackage(packageName) {
  await globalThis.webR.evalRVoid(`library(${packageName});`);
}

// Generic function to process R packages
async function qwebrProcessRPackagesWithStatus(packages, processType, displayStatusMessageUpdate = true) {
  // Switch between contexts
  const messagePrefix = processType === 'install' ? 'Installing' : 'Loading';

  // Modify button state
  qwebrSetInteractiveButtonState(`ðŸŸ¡ ${messagePrefix} package ...`, false);

  // Iterate over packages
  for (let i = 0; i < packages.length; i++) {
    const activePackage = packages[i];
    const formattedMessage = `${messagePrefix} package ${i + 1} out of ${packages.length}: ${activePackage}`;
    
    // Display the update
    if (displayStatusMessageUpdate) {
      qwebrUpdateStatusHeader(formattedMessage);
    }

    // Run package installation
    if (processType === 'install') {
      await qwebrInstallRPackage(activePackage);
    } else {
      await qwebrLoadRPackage(activePackage);
    }
  }

  // Clean slate
  if (processType === 'load') {
    await globalThis.webR.flush();
  }
}


// Check to see if any packages need to be installed
if (setupRPackages) {
  // Obtain only a unique list of packages
  const uniqueRPackageList = Array.from(new Set(installRPackagesList));

  // Install R packages one at a time (either silently or with a status update)
  await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'install', showStartupMessage);

  if(autoloadRPackages) {
    // Load R packages one at a time (either silently or with a status update)
    await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'load', showStartupMessage);
  }
}

// Stop timer
const initializeWebRTimerEnd = performance.now();

// Release document status as ready
if (showStartupMessage) {
  startupMessageWebR.innerText = "ðŸŸ¢ Ready!"
}

qwebrSetInteractiveButtonState(
  `<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run Code</span>`, 
  true
);

// Global version of the Escape HTML function that converts HTML 
// characters to their HTML entities.
globalThis.qwebrEscapeHTMLCharacters = function(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
};</script>
<script type="module">// Supported Evaluation Types for Context
globalThis.EvalTypes = Object.freeze({
    Interactive: 'interactive',
    Setup: 'setup',
    Output: 'output',
});

// Function to verify a given JavaScript Object is empty
globalThis.qwebrIsObjectEmpty = function (arr) {
    return Object.keys(arr).length === 0;
}

// Function to parse the pager results
globalThis.qwebrParseTypePager = async function (msg) { 

    // Split out the event data
    const { path, title, deleteFile } = msg.data; 

    // Process the pager data by reading the information from disk
    const paged_data = await webR.FS.readFile(path).then((data) => {
        // Obtain the file content
        let content = new TextDecoder().decode(data);

        // Remove excessive backspace characters until none remain
        while(content.match(/.[\b]/)){
        content = content.replace(/.[\b]/g, '');
        }

        // Returned cleaned data
        return content;
    });

    // Unlink file if needed
    if (deleteFile) { 
        await webR.FS.unlink(path); 
    } 

    // Return extracted data with spaces
    return paged_data;
} 

// Function to run the code using webR and parse the output
globalThis.qwebrComputeEngine = async function(
    codeToRun, 
    elements, 
    options) {

    // Call into the R compute engine that persists within the document scope.
    // To be prepared for all scenarios, the following happens: 
    // 1. We setup a canvas device to write to by making a namespace call into the {webr} package
    // 2. We use values inside of the options array to set the figure size.
    // 3. We capture the output stream information (STDOUT and STERR)
    // 4. While parsing the results, we disable image creation.

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // ---- 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid(`webr::canvas(width=${options["fig-width"]}, height=${options["fig-height"]})`);

    const result = await webRCodeShelter.captureR(codeToRun, {
        withAutoprint: true,
        captureStreams: true,
        captureConditions: false//,
        // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // -----

    // Start attempting to parse the result data
    try {

        // Stop creating images
        await webR.evalRVoid("dev.off()");

        // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
        const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
            const className = `qwebr-output-code-${evt.type}`;
            return `<code id="${className}-editor-${elements.id}-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


        // Clean the state
        // We're now able to process both graphics and pager events.
        // As a result, we cannot maintain a true 1-to-1 output order 
        // without individually feeding each line
        const msgs = await webR.flush();

        // Output each image event stored
        msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
            // Add image to the current canvas
            if (msg.data.event === 'canvasImage') {
                canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
            } else if (msg.data.event === 'canvasNewPage') {
                // Generate a new canvas element
                canvas = document.createElement("canvas");
                canvas.setAttribute("width", 2 * options["fig-width"]);
                canvas.setAttribute("height", 2 * options["fig-height"]);
                canvas.style.width = "700px";
                canvas.style.display = "block";
                canvas.style.margin = "auto";
            }
        } 
        });

        // Use `map` to process the filtered "pager" events asynchronously
        const pager = await Promise.all(
            msgs.filter(msg => msg.type === 'pager').map(
                async (msg) => {
                    return await qwebrParseTypePager(msg);
                }
            )
        );

        // Nullify the output area of content
        elements.outputCodeDiv.innerHTML = "";
        elements.outputGraphDiv.innerHTML = "";

        // Design an output object for messages
        const pre = document.createElement("pre");
        if (/\S/.test(out)) {
            // Display results as HTML elements to retain output styling
            const div = document.createElement("div");
            div.innerHTML = out;
            pre.appendChild(div);
        } else {
            // If nothing is present, hide the element.
            pre.style.visibility = "hidden";
        }

        elements.outputCodeDiv.appendChild(pre);

        // Place the graphics on the canvas
        if (canvas) {
            elements.outputGraphDiv.appendChild(canvas);
        }

        // Display the pager data
        if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
            let pre_pager = document.createElement("pre");
            pre_pager.innerText = paged_data;
            pre_pager.classList.add("qwebr-output-code-pager");
            pre_pager.setAttribute("id", `qwebr-output-code-pager-editor-${elements.id}-result-${index + 1}`);
            elements.outputCodeDiv.appendChild(pre_pager);
        });
        }
    } finally {
        // Clean up the remaining code
        webRCodeShelter.purge();
    }
}

// Function to execute the code (accepts code as an argument)
globalThis.qwebrExecuteCode = async function (
    codeToRun,
    id,
    evalType = EvalTypes.Interactive,
    options = {}) {

    // If options are not passed, we fall back on the bare minimum to handle the computation
    if (qwebrIsObjectEmpty(options)) {
        options = { "fig-width": 504, "fig-height": 360 };
    }

    // Next, we access the compute areas values
    const elements = {
        runButton: document.getElementById(`qwebr-button-run-${id}`),
        outputCodeDiv: document.getElementById(`qwebr-output-code-area-${id}`),
        outputGraphDiv: document.getElementById(`qwebr-output-graph-area-${id}`),
        id: id,
    }

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
        btn.disabled = true;
    });

    if (evalType == EvalTypes.Interactive) {
        // Emphasize the active code cell
        elements.runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run Code</span>';
    }

    // Evaluate the code and parse the output into the document
    await qwebrComputeEngine(codeToRun, elements, options);

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
        btn.disabled = false;
    });

    if (evalType == EvalTypes.Interactive) {
        // Revert to the initial code cell state
        elements.runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run Code</span>';
    }
}
</script>
<script type="module">// Function that dispatches the creation request
globalThis.qwebrCreateHTMLElement = function (insertElement,
  qwebrCounter, 
  evalType = EvalTypes.Interactive,
  options = {}) {

  // Figure out the routine to use to insert the element.
  let qwebrElement;
  switch ( evalType ) {
    case EvalTypes.Interactive: 
      qwebrElement = qwebrCreateInteractiveElement(qwebrCounter);
    case EvalTypes.Output: 
      qwebrElement = qwebrCreateNonInteractiveOutputElement(qwebrCounter);
    case EvalTypes.Setup: 
      qwebrElement = qwebrCreateNonInteractiveSetupElement(qwebrCounter);
    default: 
      qwebrElement = document.createElement('div');
      qwebrElement.textContent = 'Error creating element';
  }

  // Insert the dynamically generated object at the document location.
  insertElement.appendChild(qwebrElement);
};

// Function that setups the interactive element creation
globalThis.qwebrCreateInteractiveElement = function (qwebrCounter) {

  // Create main div element
  var mainDiv = document.createElement('div');
  mainDiv.id = 'qwebr-interactive-area-' + qwebrCounter;
  mainDiv.className = 'qwebr-interactive-area';

  // Create button element
  var button = document.createElement('button');
  button.className = 'btn btn-default qwebr-button-run';
  button.disabled = true;
  button.type = 'button';
  button.id = 'qwebr-button-run-' + qwebrCounter;
  button.textContent = 'ðŸŸ¡ Loading webR...';

  // Create console area div
  var consoleAreaDiv = document.createElement('div');
  consoleAreaDiv.id = 'qwebr-console-area-' + qwebrCounter;
  consoleAreaDiv.className = 'qwebr-console-area';

  // Create editor div
  var editorDiv = document.createElement('div');
  editorDiv.id = 'qwebr-editor-' + qwebrCounter;
  editorDiv.className = 'qwebr-editor';

  // Create output code area div
  var outputCodeAreaDiv = document.createElement('div');
  outputCodeAreaDiv.id = 'qwebr-output-code-area-' + qwebrCounter;
  outputCodeAreaDiv.className = 'qwebr-output-code-area';
  outputCodeAreaDiv.setAttribute('aria-live', 'assertive');

  // Create pre element inside output code area
  var preElement = document.createElement('pre');
  preElement.style.visibility = 'hidden';
  outputCodeAreaDiv.appendChild(preElement);

  // Create output graph area div
  var outputGraphAreaDiv = document.createElement('div');
  outputGraphAreaDiv.id = 'qwebr-output-graph-area-' + qwebrCounter;
  outputGraphAreaDiv.className = 'qwebr-output-graph-area';

  // Append all elements to the main div
  mainDiv.appendChild(button);
  consoleAreaDiv.appendChild(editorDiv);
  consoleAreaDiv.appendChild(outputCodeAreaDiv);
  mainDiv.appendChild(consoleAreaDiv);
  mainDiv.appendChild(outputGraphAreaDiv);

  return mainDiv;
}

// Function that adds output structure for non-interactive output
globalThis.qwebrCreateNonInteractiveOutputElement = function(qwebrCounter) {
  // Create main div element
  var mainDiv = document.createElement('div');
  mainDiv.id = 'qwebr-noninteractive-area-' + qwebrCounter;
  mainDiv.className = 'qwebr-noninteractive-area';

  // Create output code area div
  var outputCodeAreaDiv = document.createElement('div');
  outputCodeAreaDiv.id = 'qwebr-output-code-area-' + qwebrCounter;
  outputCodeAreaDiv.className = 'qwebr-output-code-area';
  outputCodeAreaDiv.setAttribute('aria-live', 'assertive');

  // Create pre element inside output code area
  var preElement = document.createElement('pre');
  preElement.style.visibility = 'hidden';
  outputCodeAreaDiv.appendChild(preElement);

  // Create output graph area div
  var outputGraphAreaDiv = document.createElement('div');
  outputGraphAreaDiv.id = 'qwebr-output-graph-area-' + qwebrCounter;
  outputGraphAreaDiv.className = 'qwebr-output-graph-area';

  // Append all elements to the main div
  mainDiv.appendChild(outputCodeAreaDiv);
  mainDiv.appendChild(outputGraphAreaDiv);

  return mainDiv;
};

// Function that adds a stub in the page to indicate a setup cell was used.
globalThis.qwebrCreateNonInteractiveSetupElement = function(qwebrCounter) {
  // Create main div element
  var mainDiv = document.createElement('div');
  mainDiv.id = 'qwebr-noninteractive-setup-area-' + qwebrCounter;
  mainDiv.className = 'qwebr-noninteractive-setup-area';

  return mainDiv;
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../webex.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notes/chapter10.html">Part 2: Statistics</a></li><li class="breadcrumb-item"><a href="../notes/chapter17.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Nonparametric Hypothesis Testing</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Understanding Uncertainty</a> 
        <div class="sidebar-tools-main">
    <a href="../Understanding-Uncertainty.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 1: Probability</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Probability</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Mathematical Foundations of Statistical Experiments</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">The Core Concepts of Probability</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Probabilities with More than One Event</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Summarizing Statistical Experiments with Random Variables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">The Expected Value, Location Summaries, and Measures of Variability</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Expectations and Variances with Multiple Random Variables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">The Named Discrete Distributions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Continuous Random Variables</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 2: Statistics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Introduction to Statistics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">An Introduction to Descriptive Statistics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Sampling Distributions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Methods of Estimation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Confidence Intervals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">The Basics of Null Hypothesis Significance Testing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Hypothesis Testing and Confidence Intervals in Two Populations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter17.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Nonparametric Hypothesis Testing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter18.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">The Analysis of Categorical Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter19.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Simple Linear Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/chapter20.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">The One-Way ANOVA</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#nonparametric-procedures-in-general" id="toc-nonparametric-procedures-in-general" class="nav-link active" data-scroll-target="#nonparametric-procedures-in-general"><span class="header-section-number">17.1</span> Nonparametric Procedures in General</a></li>
  <li><a href="#nonparametric-hypothesis-tests-for-location" id="toc-nonparametric-hypothesis-tests-for-location" class="nav-link" data-scroll-target="#nonparametric-hypothesis-tests-for-location"><span class="header-section-number">17.2</span> Nonparametric Hypothesis Tests for Location</a></li>
  <li><a href="#the-wilcoxon-signed-rank-test" id="toc-the-wilcoxon-signed-rank-test" class="nav-link" data-scroll-target="#the-wilcoxon-signed-rank-test"><span class="header-section-number">17.3</span> The Wilcoxon Signed-Rank Test</a>
  <ul class="collapse">
  <li><a href="#non-centered-data-ties-and-zeroes" id="toc-non-centered-data-ties-and-zeroes" class="nav-link" data-scroll-target="#non-centered-data-ties-and-zeroes"><span class="header-section-number">17.3.1</span> Non-Centered Data, Ties, and Zeroes</a></li>
  </ul></li>
  <li><a href="#the-mann-whitney-u-test" id="toc-the-mann-whitney-u-test" class="nav-link" data-scroll-target="#the-mann-whitney-u-test"><span class="header-section-number">17.4</span> The Mann-Whitney <span class="math inline">\(U\)</span>-Test</a>
  <ul class="collapse">
  <li><a href="#the-mann-whitney-u-test-for-location-shift-distributions" id="toc-the-mann-whitney-u-test-for-location-shift-distributions" class="nav-link" data-scroll-target="#the-mann-whitney-u-test-for-location-shift-distributions"><span class="header-section-number">17.4.1</span> The Mann-Whitney <span class="math inline">\(U\)</span>-Test for Location Shift Distributions</a></li>
  </ul></li>
  <li><a href="#the-wilcoxon-signed-rank-test-for-paired-data" id="toc-the-wilcoxon-signed-rank-test-for-paired-data" class="nav-link" data-scroll-target="#the-wilcoxon-signed-rank-test-for-paired-data"><span class="header-section-number">17.5</span> The Wilcoxon Signed-Rank Test (for Paired Data)</a>
  <ul class="collapse">
  <li><a href="#non-centered-data-ties-and-zeroes-1" id="toc-non-centered-data-ties-and-zeroes-1" class="nav-link" data-scroll-target="#non-centered-data-ties-and-zeroes-1"><span class="header-section-number">17.5.1</span> Non-Centered Data, Ties, and Zeroes</a></li>
  </ul></li>
  <li><a href="#the-intuition-of-rank-based-tests" id="toc-the-intuition-of-rank-based-tests" class="nav-link" data-scroll-target="#the-intuition-of-rank-based-tests"><span class="header-section-number">17.6</span> The Intuition of Rank-Based Tests</a></li>
  <li><a href="#non-parametric-tests-procedures-in-r" id="toc-non-parametric-tests-procedures-in-r" class="nav-link" data-scroll-target="#non-parametric-tests-procedures-in-r"><span class="header-section-number">17.7</span> Non-Parametric Tests Procedures in <code>R</code></a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
<script type="module" id="qwebr-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
    }
  });
</script>
<script type="module">// Global dictionary to store Monaco Editor instances
const qwebrEditorInstances = {};

// Function that builds and registers a Monaco Editor instance    
globalThis.qwebrCreateMonacoEditorInstance = function (
    initialCode, 
    qwebrCounter) {

  // Retrieve the previously created document elements
  let runButton = document.getElementById(`qwebr-button-run-${qwebrCounter}`);
  let editorDiv = document.getElementById(`qwebr-editor-${qwebrCounter}`);
  
  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: initialCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // Works wonderfully with RevealJS
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',              // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Store the official counter ID to be used in keyboard shortcuts
    editor.__qwebrCounter = qwebrCounter;

    // Store the official div container ID
    editor.__qwebrEditorId = `qwebr-editor-${qwebrCounter}`;

    // Store the initial code value
    editor.__qwebrinitialCode = initialCode;

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        qwebrExecuteCode(editor.getValue(), editor.__qwebrCounter);
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          qwebrExecuteCode(currentLine, editor.__qwebrCounter,
            EvalTypes.Interactive);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          qwebrExecuteCode(selectedText, editor.__qwebrCounter, EvalTypes.Interactive);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();

    // Store the editor instance in the global dictionary
    qwebrEditorInstances[editor.__qwebrCounter] = editor;

  });

  // Add a click event listener to the run button
  runButton.onclick = function () {
    qwebrExecuteCode(editor.getValue(), editor.__qwebrCounter, EvalTypes.Interactive);
  };

}</script>

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notes/chapter10.html">Part 2: Statistics</a></li><li class="breadcrumb-item"><a href="../notes/chapter17.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Nonparametric Hypothesis Testing</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Nonparametric Hypothesis Testing</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="nonparametric-procedures-in-general" class="level2" data-number="17.1">
<h2 data-number="17.1" class="anchored" data-anchor-id="nonparametric-procedures-in-general"><span class="header-section-number">17.1</span> Nonparametric Procedures in General</h2>
<p>Ultimately, hypothesis testing procedures for the mean that rely on <span class="math inline">\(Z\)</span> or <span class="math inline">\(t\)</span> statistics have theory that is founded upon normality assumptions. The standardized test statistic, <span class="math display">\[T = \frac{\overline{X} - \mu_0}{S/\sqrt{n}},\]</span> has a <span class="math inline">\(t_{n-1}\)</span> distribution under the null whenever <span class="math inline">\(\overline{X}\)</span> is normally distributed. This is typically justified in one of two ways. First, many quantities that arise in practice are very close to being normally distributed. As a result, many physical quantities that we are interested in will have a population that is conducive to this testing in this manner. Alternatively, by appealing to the Central Limit Theorem, whenever the sample size is large enough, regardless of the population distribution, <span class="math inline">\(\overline{X}\)</span> should be approximately normally distributed. As a result, in large samples, these <span class="math inline">\(t\)</span> and <span class="math inline">\(Z\)</span> procedures can be justified. Depending on how strongly you desire rigorous justifications for mathematical procedures, these justifications may feel inadequate to support the widespread use of <span class="math inline">\(t\)</span>-tests. In both cases, the theory that has been developed is only <em>approximately</em> justified. This may lead one to question whether there are alternative procedures to perform the same types of hypothesis testing, but which do not rely on assuming that the estimator follows a normal distribution.</p>
<p>This question goes beyond the setting of hypothesis testing. Many statistical procedures rely either explicitly or implicitly on assumptions regarding the population distribution, at least for their theoretical justifications. These procedures are referred to as <strong>parametric methods</strong> since they rely on assumptions regarding the <em>parametric form</em> of the distribution.</p>
<div id="def-parametric-method" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 17.1 (Parametric Method)</strong></span> A <strong>parametric method</strong> or <strong>parametric technique</strong> is a statistical procedure that relies on assumptions regarding the specific structure of the distributions of the random variables of interest. Typically, this will come in the form of assuming that the data follow some specific distribution, even if the values of the parameters are left unspecified.</p>
</div>
<p>Parametric methods are incredibly useful, and largely serve as the foundation for the most widely applied statistical methods. The concern with parametric methods, as discussed for the specific case of hypothesis testing, is that these methods are theoretically justified only when the parametric assumptions hold. If a population is assumed to follow a normal distribution, and it does not in fact follow the normal distribution, the theory can no longer provide guarantees as to the performance of the procedure. This does not necessarily mean that the procedure will not perform well, however, it does mean that justification for the application of the procedure is lacking. There are secondary approaches in statistics that remedy this, broadly referred to as <strong>nonparametric methods</strong>.</p>
<div id="def-nonparametric-method" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 17.2 (Nonparametric Method)</strong></span> A <strong>nonparametric method</strong> or <strong>nonparametric technique</strong> is a statistical procedure that does not rely upon strict assumptions regarding the structure of the distribution of the underlying random variables. Nonparametric techniques may make minimal assumptions regarding the shape of the distribution, such as assuming that the population distribution is symmetric. These assumptions are typically far less restrictive or easier to assess in practice.</p>
</div>
<p>Nonparametric techniques are designed to be flexible, and to apply well in a wide range of scenarios. This way, there can be confidence in the results obtained by applying the procedure, even when little is known or can be assumed about the underlying population distribution. This makes nonparametric methods attractive in a variety of settings. In the previous context, where we desire hypothesis tests for the mean that are not dependent on assumptions of normality, we can state this more plainly as desiring a nonparametric hypothesis testing procedure.</p>
</section>
<section id="nonparametric-hypothesis-tests-for-location" class="level2" data-number="17.2">
<h2 data-number="17.2" class="anchored" data-anchor-id="nonparametric-hypothesis-tests-for-location"><span class="header-section-number">17.2</span> Nonparametric Hypothesis Tests for Location</h2>
<p>It is frequently the case that scientific questions of interest center on the location of a population. Often this will be questions regarding the mean of a distribution, though, in certain contexts, the median or similar measures may be of particular interest. As a result, commonly used procedures for statistical inference are commonly motivated by questions relating to population locations. This is true for both parametric and nonparametric techniques.</p>
<p>When considering the application of nonparametric statistical inference, it is important to recognize some intricacies that arise when we are unwilling to make concrete assumptions regarding the population distribution. Notably, if we are willing to assume that the population is well-behaved,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> then we are able to talk concretely about the parameters that specify these distributions. If instead we want to use a nonparametric technique, we forego the capacity to make these nice generalizations. By leaving the distributions we are considering unrestricted, it can be challenging to even specify the null or alternative hypothesis that we are interested in testing.</p>
<p>There are many distributions that are particularly poorly behaved. For instance, there are distributions that do not have means, or do not have variances. This is a strange concept, to have a distribution that is well-defined, and may very well describe data arising from some population, but which does not possess a mean or a variance. Still, if we want to consider truly nonparametric techniques, it is important that our methods recognize and account for this reality.</p>
<p>When approaching hypothesis testing nonparametrically, instead of discussing hypothesis tests for the mean of a distribution, we more commonly discuss hypothesis testing for the <em>location</em> of a distribution. The location of the distribution (<a href="chapter6.html#def-location" class="quarto-xref">Definition&nbsp;<span>6.1</span></a>) may correspond to the mean, when it exists, or the median, or similar related measurements. Despite this linguistic difference, nonparametric tests for the location of a distribution are analogous to parametric tests for the mean of a distribution.</p>
<p>Just as is the case with parametric hypothesis tests for the mean, there are multiple nonparametric hypothesis tests for the location of a population. These tests apply in different settings, depending on the available data, the specific parameter of interest, or the assumptions that the analyst is willing to make.</p>
</section>
<section id="the-wilcoxon-signed-rank-test" class="level2" data-number="17.3">
<h2 data-number="17.3" class="anchored" data-anchor-id="the-wilcoxon-signed-rank-test"><span class="header-section-number">17.3</span> The Wilcoxon Signed-Rank Test</h2>
<p>The simplest setup for a nonparametric test of location takes a single sample, denoted <span class="math inline">\(X_1, \dots, X_n\)</span>, from an unknown distribution. To begin, assume that there are no zeros in the data, and that no two observations have the same absolute value. While we do not assume any parametric form for the distribution, we will assume that the distribution is <strong>symmetric</strong>. In this setting, we are concerned with testing a null hypothesis of the form <span class="math inline">\(H_0: \mu = 0\)</span> versus the alternative <span class="math inline">\(H_A: \mu \neq 0\)</span>. Here, <span class="math inline">\(\mu\)</span> represents the location of the distribution. Because we assume that the distribution is symmetric, the mean<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> will coincide with the median, and as such, there is a candidate for a single measure of location. We may also wish to consider one-tail alternatives, either taking <span class="math inline">\(H_0: \mu \geq 0\)</span> versus <span class="math inline">\(H_A: \mu &lt; 0\)</span>, or <span class="math inline">\(H_0: \mu \leq 0\)</span> versus <span class="math inline">\(H_A: \mu &gt; 0\)</span>.</p>
<p>To test the hypothesis in this setting, we can make use of <strong>Wilcoxonâ€™s Signed-Rank Test</strong>. In order to perform this test we need to consider the signed-rank of every observation, and then use these to compute a test statistic. Consider first the magnitude of each observed data point. That is, take <span class="math inline">\(|X_1|, |X_2|, |X_3|, \dots, |X_n|\)</span>. Each of these will produce a value that is (at least) zero. Further, by assumption, none of these values repeat. We can then consider ranking these magnitudes from smallest to largest, and assigning them their corresponding <strong>rank</strong>, <span class="math inline">\(R_1, R_2, \dots, R_n\)</span>.</p>
<p>For instance, suppose that we observe the sample <span class="math inline">\(\{-2, 1, -7, 9, 6\}\)</span>. Then, we first consider the magnitudes of each term in the sample, giving <span class="math inline">\(\{2, 1, 7, 9 6\}\)</span>. Next, we sort this set from smallest to largest, giving <span class="math inline">\(\{1, 2, 6, 7, 9\}\)</span>. Thus, the observation <span class="math inline">\(1\)</span> will receive a rank of <span class="math inline">\(1\)</span>, the observation <span class="math inline">\(-2\)</span> will receive a rank of <span class="math inline">\(2\)</span>, the observation <span class="math inline">\(6\)</span> will receive a rank of <span class="math inline">\(3\)</span>, the observation <span class="math inline">\(-7\)</span> will receive a rank of <span class="math inline">\(4\)</span>, and the observation <span class="math inline">\(9\)</span> will receive a rank of <span class="math inline">\(5\)</span>. We can summarize this, noting: <span class="math display">\[(x_1, x_2, x_3, x_4, x_5) = (-2, 1, -7, 9, 6) \quad\text{and}\quad (r_1, r_2, r_3, r_4, r_5) = (2, 1, 4, 5, 3).\]</span></p>
<p>With the ranks for each observation recorded, then we compute the <strong>signed-rank sum</strong>, denoted <span class="math inline">\(T\)</span>. Namely, taking <span class="math inline">\(\text{sgn}(x)\)</span> to represent the sign of <span class="math inline">\(x\)</span>, such that <span class="math inline">\(\text{sgn}(x) = -1\)</span> if <span class="math inline">\(x &lt; 0\)</span> and <span class="math inline">\(\text{sgn}(x) = 1\)</span> if <span class="math inline">\(x &gt; 0\)</span>, then <span class="math display">\[T = \sum_{i=1}^N \text{sgn}(X_i)R_i.\]</span> Under the null hypothesis, <span class="math inline">\(H_0: \mu = 0\)</span>, the signed-rank sum will be distributed according to the <strong>signed-rank distribution</strong>, parameterized by <span class="math inline">\(n\)</span>, the total sample size.</p>
<div id="def-signed-rank-sum" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 17.3 (Signed-Rank Sum)</strong></span> The <strong>signed-rank sum</strong>, denoted <span class="math inline">\(T\)</span>, is a test statistic used for nonparametric testing of a population location. Given data <span class="math inline">\((X_1, \dots, X_n)\)</span>, the data is first transformed into a set of ranks, <span class="math inline">\((R_1, \dots, R_n)\)</span>, determined by ranking the absolute values, <span class="math inline">\((|X_1|, \dots, |X_n|)\)</span>. Then, <span class="math display">\[T = \sum_{i=1}^n \text{sgn}(X_i)R_i.\]</span></p>
</div>
<p>The <span class="math inline">\(p\)</span>-value can then be determined on the basis of the signed-rank distribution. Namely, taking <span class="math inline">\(F_n\)</span> to be the cumulative distribution function for the signed-rank distribution based on a sample of size <span class="math inline">\(n\)</span>, then <span class="math display">\[p = P(T \leq -|t|) + P(T \geq |t|) = F_n(-|t|) + 1 - F_n(|t|-1) = 2F_n(-|t|).\]</span> Note that the signed-rank distribution is a discrete distribution. As a result, it is not true to say <span class="math inline">\(P(T \geq t) = 1 - F_n(t)\)</span>. Instead, <span class="math inline">\(P(T &gt; t) = 1 - F_n(t)\)</span>, and <span class="math inline">\(P(T \geq t) = P(T &gt; t-1)\)</span>. Thus, when computing the <span class="math inline">\(p\)</span>-value, we must take <span class="math inline">\(F_n(-|t|) + 1 - F_n(|t|-1)\)</span>, or the more simple <span class="math inline">\(2F_n(t)\)</span>. Computing probabilities for the signed rank distribution is feasible, using a computer, for small values of <span class="math inline">\(n\)</span>. For larger values of <span class="math inline">\(n\)</span>, however, this is not the case. Instead, if <span class="math inline">\(n\)</span> is sufficiently large, then the signed-rank distribution is approximately normal, with a mean of <span class="math inline">\(0\)</span> and a variance of <span class="math inline">\(\dfrac{n(n+1)(2n+1)}{6}\)</span>. Thus, for large <span class="math inline">\(n\)</span>, the <span class="math inline">\(p\)</span>-value can be approximated as <span class="math display">\[p \approx 2\times\Phi\left(-\frac{|t|}{\sqrt{n(n+1)(2n+1)/6}}\right).\]</span></p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Wilcoxon Signed-Rank Tests for Single Populations (Without Ties)
</div>
</div>
<div class="callout-body-container callout-body">
<p>If data are selected from a symmetric population, and are such that the absolute values of all observed data points are unique, then the Wilcoxon Signed-Rank test can be used to test <span class="math inline">\(H_0: \mu = 0\)</span> versus <span class="math inline">\(H_0: \mu \neq 0\)</span>, or the one-tailed alternatives, where <span class="math inline">\(\mu\)</span> is the population location. To do so, the <strong>signed-rank sum</strong> test statistic is computed, <span class="math display">\[T = \sum_{i=1}^n \text{sgn}(X_i)R_i,\]</span> where <span class="math inline">\(R_i\)</span> is the rank order (smallest to largest) of <span class="math inline">\(|X_i|\)</span>.</p>
<p>Under the null hypothesis, <span class="math inline">\(T\)</span> follows a signed-rank distribution with size parameter <span class="math inline">\(n\)</span>. Taking <span class="math inline">\(T = t\)</span> based on the observed sample, the <span class="math inline">\(p\)</span>-value can be computed as:</p>
<ol type="1">
<li>If <span class="math inline">\(H_0: \mu = 0\)</span> versus <span class="math inline">\(H_A: \mu \neq 0\)</span>, then <span class="math display">\[p = F_n(-|t|) + 1 - F_n(|t|) \approx 2\Phi\left(-|t|/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
<li>If <span class="math inline">\(H_0: \mu \leq 0\)</span> versus <span class="math inline">\(H_A: \mu &gt; 0\)</span>, then <span class="math display">\[p = 1 - F_n(t) \approx 1 - \Phi\left(t/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
<li>If <span class="math inline">\(H_0: \mu \geq 0\)</span> versus <span class="math inline">\(H_A: \mu &lt; 0\)</span>, then <span class="math display">\[p = F_n(t) \approx \Phi\left(t/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
</ol>
</div>
</div>
<section id="non-centered-data-ties-and-zeroes" class="level3" data-number="17.3.1">
<h3 data-number="17.3.1" class="anchored" data-anchor-id="non-centered-data-ties-and-zeroes"><span class="header-section-number">17.3.1</span> Non-Centered Data, Ties, and Zeroes</h3>
<p>The Wilcoxon signed-rank test can only test the null hypothesis <span class="math inline">\(H_0: \mu = 0\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> This is useful whenever you expect that data are already centered, or if <span class="math inline">\(0\)</span> is truly the location of interest. Frequently, non-zero values for the location will be of interest. If there is a desire to test <span class="math inline">\(H_0: \mu = \mu_0\)</span>, for <span class="math inline">\(\mu_0 \neq 0\)</span>, then before the test can be run, the data need to first be centered. To do so, the observations <span class="math inline">\((X_1,\dots,X_n)\)</span> can be transformed into <span class="math inline">\((Z_1, \dots, Z_n) = (X_1 - \mu_0, \dots, X_n - \mu_0)\)</span>.</p>
<p>If the null hypothesis holds then <span class="math inline">\(X_i\)</span> is symmetric with location <span class="math inline">\(\mu_0\)</span>. Thus, by shifting the entire distribution, it must be the case that <span class="math inline">\(Z_i\)</span> is centered with location <span class="math inline">\(0\)</span>. As such, the Wilcoxon signed-rank test can then be applied to the computed <span class="math inline">\(Z_i\)</span> testing <span class="math inline">\(H_0: \mu_Z = 0\)</span> versus <span class="math inline">\(H_A: \mu_Z \neq 0\)</span>. This is equivalent to testing <span class="math inline">\(H_0: \mu = \mu_0\)</span> versus <span class="math inline">\(H_A: \mu \neq \mu_0\)</span>.</p>
<p>A secondary concern is the accommodation of tied ranks. Specifically, if there are two observations with the same magnitude then the procedure cannot proceed as described, as there is not a unique rank for each observed point. This presents challenges, particularly when analyzing discrete data, where ties may be prevalent. While several tie-breaking procedures exist, two common approaches are the <em>average rank procedure</em> and the <em>random rank procedure</em>. In the average rank procedure, the rank of any observation is the average of all possible ranks it could take on, if ties were broken in any possible way. Suppose that two points, <span class="math inline">\(X_2\)</span> and <span class="math inline">\(X_8\)</span>, have the same magnitude, and should be ranked as <span class="math inline">\(2\)</span> or <span class="math inline">\(3\)</span>. Then, in the average rank procedure, both would receive a rank of <span class="math inline">\(r = \dfrac{2+3}{2} = 2.5\)</span>. The random rank procedure, on the other hand, breaks ties completely at random. For any tied points, the order within the ties is randomly selected, and test proceeds as though those are the true ranks.</p>
<p>If the average rank procedure is used, the distribution under the null hypothesis changes slightly. It is still referred to as a signed-rank distribution, but it is a signed-rank distribution with average ranks. This is not a problem, computationally, but it does render the null distribution contingent on the observed data. There are further theoretical concerns with the average rank procedure that, in certain settings, can lead to paradoxical conclusions.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The random rank procedure, on the other hand, produces a test statistic with the same null distribution regardless of whether ties exist or not. The primary drawback in this case is that the specific test statistic, and as such <span class="math inline">\(p\)</span>-value and conclusion, is dependent on both the observed data and the random rankings. To limit the impact that this has on final results, some researchers will run random ranking many times, and either collect the set of observed <span class="math inline">\(p\)</span>-values or else average the set of <span class="math inline">\(p\)</span>-values.</p>
<p>There is no single, universally preferred procedure for addressing ties. The most common approach in statistical software is<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> the average rank procedure. However, the drawbacks with paradoxical conclusions can be severe and limiting. Random ranking avoids these issues, but at the cost of a more arbitrary test statistic, depending on additional randomness. Some researchers have proposed variations on these techniques, or new tie-breaking procedures all together. While any approach is likely to produce satisfactory results in the event of a few ties within the data, should there be a very large number of ties it is likely preferable to consider alternative test procedures that directly accommodate the data.</p>
<p>A final concern in the application of the Wilcoxon signed-rank test is the presence of zeroes. There are two common approaches for addressing zeros: the <em>reduced sample procedure</em> and the <em>signed-rank zero procedure</em>. In the reduced sample procedure, zeroes are simply dropped from the sample. Then, the test procedure runs exactly as before. This is an easy approach, and does not require the null distribution to change, but has similar drawbacks to the average rank procedure described above. In particular, the reduce sample procedure may produce paradoxical conclusions. Alternatively, the signed-rank zero procedure still ranks the zeros, and defines <span class="math inline">\(\text{sgn}(0) = 0\)</span>. This way, all data are still ranked and included within the test statistic. This has several theoretical benefits over the reduced sample procedure, including resolving the paradoxical conclusions that can arise, but has the disadvantage of changing the null distribution in the presence of zeroes.</p>
<p>Between the two techniques, there is no statistically optimal approach. In certain cases the reduced sample procedure will outperform the signed-rank zero procedure, and vice versa. Just as with ties, most software implementations will have a technique for accounting for zeroes in the data. These techniques will likely perform suitably well for data with minimal zeroes, however, in the event of data with an abundance of zeroes, it is likely worthwhile to consider alternative test procedure all together.</p>
</section>
</section>
<section id="the-mann-whitney-u-test" class="level2" data-number="17.4">
<h2 data-number="17.4" class="anchored" data-anchor-id="the-mann-whitney-u-test"><span class="header-section-number">17.4</span> The Mann-Whitney <span class="math inline">\(U\)</span>-Test</h2>
<p>The signed-rank test allowed for nonparametric tests regarding a single population. A simple extension to this setting is the desire to run a hypothesis test comparing two independent populations. Suppose that <span class="math inline">\(X_{1},\dots,X_n\)</span> are drawn from the first population and <span class="math inline">\(Y_1,\dots,Y_m\)</span> are drawn from the second. General interest may be in whether the distribution of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are equivalent to one another, or not.</p>
<p>Considering the equivalence of the distributions tends to be a stronger requirement than in the parametric case of comparing equality of means. However, it is worth revisiting why this may be reasonable. Specifically, in the nonparametric case, it is not guaranteed that any two distributions can be characterized by the same parameters. One distribution may have a mean, while the other does not. In this setting, it would not be reasonable to compare population means, since there are not two means to compare. If, when running the test comparing the populations, you are willing to make stronger assumptions regarding the distribution, it is possible to convert a test of equality of distributions into a direct test of location measures. For instance, suppose you are willing to assume that the population distributions of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are equivalent except for, perhaps, their location. In this case testing whether the distributions are equivalent is the same as testing whether the locations are equal. In the standard <span class="math inline">\(t\)</span>-test, this is essentially the assumption that is made. For nonparametric testing, it is useful to leave this more broad.</p>
<p>Denoting the cumulative distribution function of the first population, <span class="math inline">\(F_X\)</span>, and of the second population, <span class="math inline">\(F_Y\)</span>, the process of testing for equality of distributions can be expressed as testing the null hypothesis <span class="math inline">\(H_0: F_X = F_Y\)</span> versus the alternative <span class="math inline">\(H_A: F_X \neq F_Y\)</span>. To do this nonparametrically, we can apply the Mann-Whitney <span class="math inline">\(U\)</span>-test. The Mann-Whitney <span class="math inline">\(U\)</span>-test is also referred to as the rank-sum test, the Mann-Whitney-Wilcoxon test, or the Wilcoxon rank-sum test. To ensure that the test remains clearly distinguished from the signed-rank test, it will be referred to as the <span class="math inline">\(U\)</span>-test. The <span class="math inline">\(U\)</span>-test, like the signed-rank test, relies on the ranks of the data. Unlike the signed-rank test, however, these are not the ranks of the absolute values, but rather the ranks of the data directly. Specifically, consider the combined sample of <span class="math inline">\(\{X_1,X_2,\dots,X_n,Y_1,Y_2,\dots,Y_m\}\)</span>. Within this sample, rank all the observations from smallest to largest, assigning the ranks as <span class="math inline">\(\{R_1,R_2,\dots,R_{n+m}\}\)</span>. If there are any ties, the average-rank procedure is used. That is to say that each observation gets the average rank that would be given if we resolved ties according to every possible reordering.</p>
<p>With the ranks for each data point computed, we can then compute the <strong>rank-sum</strong> for each sample. Namely, take <span class="math inline">\(R_X\)</span> to be the sum of all the ranks from the observations corresponding to <span class="math inline">\(\{X_1,\dots,X_n\}\)</span> and <span class="math inline">\(R_Y\)</span> to be the sum of all the ranks from the observations corresponding to <span class="math inline">\(\{Y_1,\dots,Y_m\}\)</span>. That is, <span class="math display">\[R_X = \sum_{i=1}^n R_i \quad\text{and}\quad R_Y = \sum_{i=1}^m R_{n+i}.\]</span> Once the rank-sum is calculated for both samples, the <span class="math inline">\(U\)</span>-statistics can be as well. Specifically take <span class="math display">\[U_X = nm + \frac{n(n+1)}{2} - R_X \quad\text{and}\quad U_Y = nm + \frac{m(m+1)}{2} - R_Y.\]</span></p>
<p>The <strong>Mann-Whitney <span class="math inline">\(U\)</span>-Statistic</strong> is then given by <span class="math inline">\(U = \min\{U_X, U_Y\}\)</span>. Under the null hypothesis, the <span class="math inline">\(U\)</span>-statistic will follow the Wilcoxon rank-sum distribution. This distribution is characterized by both sample sizes, <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>. Thus, taking <span class="math inline">\(F_{n,m}\)</span> to be the cumulative distribution function for the Wilcoxon rank-sum distribution, then the <span class="math inline">\(p\)</span>-value for the <span class="math inline">\(U\)</span>-test will be <span class="math display">\[p = 2\times\min\{F_{n,m}(u), 1 - F_{n,m}(u)\}.\]</span> The form of this <span class="math inline">\(p\)</span>-value arises since the distribution will not be symmetric around <span class="math inline">\(0\)</span>.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> When both <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are large, then the null distribution is well-approximated by a normal distribution. Specifically, for large <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>, <span class="math display">\[U \stackrel{\dot H_0}{\sim} N\left(\frac{nm}{2}, \frac{nm(n+m+1)}{12}\right).\]</span> Thus, for the <span class="math inline">\(p\)</span>-value, <span class="math display">\[p \approx 2\times\Phi\left(-\frac{|U - nm/2|}{\sqrt{nm(n+m+1)/12}}\right).\]</span></p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Mann-Whitney <span class="math inline">\(U\)</span>-Test (General)
</div>
</div>
<div class="callout-body-container callout-body">
<p>Suppose that two independent samples are drawn from two separate populations, denoted <span class="math inline">\(X_1,\dots,X_n\)</span> from the first and <span class="math inline">\(Y_1,\dots,Y_m\)</span> from the second. The distribution function for <span class="math inline">\(X_i\)</span> is <span class="math inline">\(F_X\)</span> and the distribution function for <span class="math inline">\(Y_i\)</span> is <span class="math inline">\(F_Y\)</span>. To test the null hypothesis that the distributions are equivalent, <span class="math inline">\(H_0: F_X = F_Y\)</span>, versus the alternative that they differ, <span class="math inline">\(H_A: F_X \neq F_Y\)</span>, the Mann-Whitney <span class="math inline">\(U\)</span>-test can be run. First, all data from the two samples are combined and ranked. Then, the rank-sum statistics are computed for both samples, giving <span class="math inline">\(R_X\)</span> and <span class="math inline">\(R_Y\)</span>. Using these statistics, the <span class="math inline">\(U\)</span>-statistics for each sample are computed as <span class="math display">\[U_X = nm + \frac{n(n+1)}{2} - R_X \quad\text{and}\quad U_Y = nm + \frac{m(m+1)}{2} - R_Y.\]</span> Finally, <span class="math inline">\(U = \min\{U_X, U_Y\}\)</span> is calculated as the <span class="math inline">\(U\)</span> statistic.</p>
<p>Under the null hypothesis, <span class="math inline">\(U\)</span> follows a rank-sum distribution with size parameters <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>. Taking <span class="math inline">\(U = u\)</span> based on the observed sample, the <span class="math inline">\(p\)</span>-value can be computed as: <span class="math display">\[p = 2\times\min\{F_{n,m}(u), 1 - F_{n,m}(u)\} \approx 2\times\Phi\left(-\frac{|U - nm/2|}{\sqrt{nm(n+m+1)/12}}\right).\]</span></p>
</div>
</div>
<div class="callout callout-style-default callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Formality Under the Alternative
</div>
</div>
<div class="callout-body-container callout-body">
<p>In order for the <span class="math inline">\(U\)</span>-test to give consistent,<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> accurate results, then a further assumption is required under the alternative hypothesis. Namely, it must be the case that <span class="math inline">\(P(X &gt; Y) \neq P(Y &gt; X)\)</span> if the <strong>alternative hypothesis</strong> holds. Thus, if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> both have symmetric distributions, centered on the same value, then the <span class="math inline">\(U\)</span>-test will not reliably conclude that the distributions are different, even when sample sizes grow indefinitely. This is a fairly technical consideration, but it is important when applying the <span class="math inline">\(U\)</span>-test in practice. If you suspect that the two distributions are symmetric, and centered on the same value, the hypothesis test is no longer correctly regarded as testing <span class="math inline">\(F_X = F_Y\)</span>. To do so, alternative test procedures would be required.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
</div>
</div>
<section id="the-mann-whitney-u-test-for-location-shift-distributions" class="level3" data-number="17.4.1">
<h3 data-number="17.4.1" class="anchored" data-anchor-id="the-mann-whitney-u-test-for-location-shift-distributions"><span class="header-section-number">17.4.1</span> The Mann-Whitney <span class="math inline">\(U\)</span>-Test for Location Shift Distributions</h3>
<p>Because the null hypothesis is that the two distributions are equivalent, it is possible to reject the null hypothesis when the location of the two samples is equivalent. This is because two distributions that share a location are not necessarily equivalent. Consider, for instance, the <span class="math inline">\(N(0,1)\)</span> and <span class="math inline">\(t_3\)</span> distributions. Both have a location of <span class="math inline">\(0\)</span>, but otherwise behave quite differently. This is a desirable property of the <span class="math inline">\(U\)</span>-test, that makes it broadly applicable. However, on occasion it may be desirable to test whether <span class="math inline">\(\mu_X = \mu_Y\)</span>, or more broadly, <span class="math inline">\(H_0: \mu_X - \mu_Y = \Delta_0\)</span>, for some fixed constant. The <span class="math inline">\(U\)</span>-test can be extended to this setting, under <strong>stricter assumptions</strong> regarding the null and alternative distributions.</p>
<p>Namely, if it is assumed that <span class="math inline">\(F_X(x) = F_Y(y + \delta)\)</span>, for some value <span class="math inline">\(\delta\)</span>, then we are in effect saying that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> have equivalent distributions, except they are shifted away from one another by <span class="math inline">\(\delta\)</span>. In this context, testing whether <span class="math inline">\(F_X\)</span> and <span class="math inline">\(F_Y\)</span> are equivalent is the same as testing whether <span class="math inline">\(\delta = 0\)</span>, or alternatively, whether <span class="math inline">\(\mu_X = \mu_Y\)</span>. Thus, if we are willing to assume that it is impossible for the distributions of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> to differ, except in location, then the <span class="math inline">\(U\)</span>-test becomes a test about the equality of those locations. Note that it is not possible to test the assumption that the distributions are otherwise equivalent, and as a result, using the <span class="math inline">\(U\)</span>-test in this way is only valid when this assumption is justified via subject-matter arguments.</p>
<p>When this assumption is made, in order to test <span class="math inline">\(H_0: \mu_X - \mu_Y = \Delta_0\)</span>, the <span class="math inline">\(U\)</span>-test can be directly applied to <span class="math inline">\(X_1,\dots,X_n\)</span> for the first sample, and <span class="math inline">\(Y_1 + \Delta_0, \dots, Y_n + \Delta_0\)</span> for the second. Note that if the null hypothesis holds, then <span class="math inline">\(\mu_X = \mu_Y + \Delta_0\)</span>, and so <span class="math inline">\(Y + \Delta_0\)</span> will have location <span class="math inline">\(\mu_X\)</span>. Then testing <span class="math inline">\(F_X = F_{Y+\Delta_0}\)</span> is equivalent to testing whether their locations are equal.</p>
</section>
</section>
<section id="the-wilcoxon-signed-rank-test-for-paired-data" class="level2" data-number="17.5">
<h2 data-number="17.5" class="anchored" data-anchor-id="the-wilcoxon-signed-rank-test-for-paired-data"><span class="header-section-number">17.5</span> The Wilcoxon Signed-Rank Test (for Paired Data)</h2>
<p>The Wilcoxon signed-rank test can be applied to test hypotheses regarding the location of a single population distribution. The Mann-Whitney <span class="math inline">\(U\)</span>-test applies to test<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> for the equality of locations of two independent populations. A third scenario that is useful to consider is testing of the location of two dependent distributions, specifically when observations from these distributions are paired.</p>
<p>Suppose that <span class="math inline">\(X_1,\dots,X_n\)</span> are observed from the first population, with some location measure, <span class="math inline">\(\mu_X\)</span>. Then, <span class="math inline">\(Y_1, \dots, Y_n\)</span> are observed from the second population, with some (possibly different) location measure, <span class="math inline">\(\mu_Y\)</span>. Further, suppose that the data are paired such that <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span> are naturally linked, <span class="math inline">\(X_2\)</span> and <span class="math inline">\(Y_2\)</span> are naturally linked, and so forth. Then, this sample can be converted into a single sample of <strong>paired differences</strong> by taking, <span class="math inline">\(D_i = X_i - Y_i\)</span> giving <span class="math display">\[(D_1, D_2, \dots, D_n) = (X_1 - Y_1, X_2 - Y_2, \dots, X_n - Y_n).\]</span></p>
<p>The location of the population <span class="math inline">\(D\)</span>, <span class="math inline">\(\mu_D\)</span>, will be equal to the difference in locations for the <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> populations. That is, <span class="math inline">\(\mu_D = \mu_X - \mu_Y\)</span>. As a result, should we wish to test <span class="math inline">\(H_0: \mu_X - \mu_Y = \Delta_0\)</span>, this is equivalent to testing <span class="math inline">\(H_0: \mu_D = \Delta_0\)</span>. Further, supposing that the distributions for both <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are symmetric, then the distribution of <span class="math inline">\(D\)</span> must also be symmetric. As a result, in this case, the Wilcoxon signed-rank test can be conducted on <span class="math inline">\((D_1, \dots, D_n)\)</span>. Specifically, the signed-rank sum can be computed based on the ranks of <span class="math inline">\((|D_1|, |D_2|, \dots, |D_n|)\)</span>, and the resulting statistic can be compared to the signed-rank distribution with size parameter <span class="math inline">\(n\)</span>.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Wilcoxon Signed-Rank Tests for Paired Populations (Without Ties)
</div>
</div>
<div class="callout-body-container callout-body">
<p>Suppose that data are selected from two symmetric populations, such that the observations are paired. First, compute the paired differences, taking <span class="math display">\[(D_1, D_2, \dots, D_n) = (X_1 - Y_1, X_2 - Y_2, \dots, X_n - Y_n).\]</span></p>
<p>Further, suppose that the paired differences are such that the absolute values of all differences are unique. Then the Wilcoxon Signed-Rank test can be used to test <span class="math inline">\(H_0: \mu_D = 0\)</span> versus <span class="math inline">\(H_0: \mu_D \neq 0\)</span>, or the one-tailed alternatives, where <span class="math inline">\(\mu_D = \mu_X - \mu_Y\)</span> is the difference in population locations. To do so, the <strong>signed-rank sum</strong> test statistic is computed, <span class="math display">\[T = \sum_{i=1}^n \text{sgn}(D_i)R_i,\]</span> where <span class="math inline">\(R_i\)</span> is the rank order (smallest to largest) of <span class="math inline">\(|D_i|\)</span>.</p>
<p>Under the null hypothesis, <span class="math inline">\(T\)</span> follows a signed-rank distribution with size parameter <span class="math inline">\(n\)</span>. Taking <span class="math inline">\(T = t\)</span> based on the observed sample, the <span class="math inline">\(p\)</span>-value can be computed as:</p>
<ol type="1">
<li>If <span class="math inline">\(H_0: \mu_D = 0\)</span> versus <span class="math inline">\(H_A: \mu_D \neq 0\)</span>, then <span class="math display">\[p = F_n(-|t|) + 1 - F_n(|t|) \approx 2\Phi\left(-|t|/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
<li>If <span class="math inline">\(H_0: \mu_D \leq 0\)</span> versus <span class="math inline">\(H_A: \mu_D &gt; 0\)</span>, then <span class="math display">\[p = 1 - F_n(t) \approx 1 - \Phi\left(t/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
<li>If <span class="math inline">\(H_0: \mu_D \geq 0\)</span> versus <span class="math inline">\(H_A: \mu_D &lt; 0\)</span>, then <span class="math display">\[p = F_n(t) \approx \Phi\left(t/\sqrt{n(n+1)(2n+1)/6}\right).\]</span></li>
</ol>
</div>
</div>
<section id="non-centered-data-ties-and-zeroes-1" class="level3" data-number="17.5.1">
<h3 data-number="17.5.1" class="anchored" data-anchor-id="non-centered-data-ties-and-zeroes-1"><span class="header-section-number">17.5.1</span> Non-Centered Data, Ties, and Zeroes</h3>
<p>Just as in the single sample case, the signed-rank test for paired data can be adjusted to accommodate ties, zeroes, and non-centered data. The same considerations can be applied to the single sample of paired differences, <span class="math inline">\((D_1,\dots,D_n)\)</span>. Shifting the observed differences by a constant allows for testing for non-zero differences. The average rank or random rank procedures can be used to accommodate ties in the differences. The reduced sample procedure or signed-rank zero procedure can both be used to accommodate zeroes in the sample. Just as was the case with the one sample procedure, any of these choices will likely produce satisfactory results when data have only a few ties or a few zeroes. When ties or zeroes are abundant, it is unlikely that the signed-rank test is the best choice for testing the location.</p>
</section>
</section>
<section id="the-intuition-of-rank-based-tests" class="level2" data-number="17.6">
<h2 data-number="17.6" class="anchored" data-anchor-id="the-intuition-of-rank-based-tests"><span class="header-section-number">17.6</span> The Intuition of Rank-Based Tests</h2>
<p>Both the Wilcoxon signed-rank test, and the Mann-Whitney <span class="math inline">\(U\)</span>-test, often called the rank-sum test, are known as rank-based test procedures. The rationale is that these are tests on statistics derived from the ranks of the data. It is worth considering the intuition between how the test statistics connect to the hypotheses of interest.</p>
<p>Consider first the signed-rank sum. For this, the data (from a single sample) are ranked from smallest to largest, and then these ranks are signed. If we add up all the signed ranks then we can think about this equivalently as adding all the ranks for points observed above <span class="math inline">\(0\)</span> and subtracting from that all ranks that were below <span class="math inline">\(0\)</span>. Under the null hypothesis, the location of the distribution is <span class="math inline">\(0\)</span>. In order for this to hold, it must be the case that it is about as likely for observations below zero to occur as it is for observations above zero. In connect this to ranks, we may suggest that there should be roughly as many small values above zero and below zero, and the same with large values. As a result, in a distribution with <span class="math inline">\(\mu = 0\)</span>, we should expect that <span class="math inline">\(T\)</span> will be approximately <span class="math inline">\(0\)</span>. If the values of this statistic are much larger or much smaller than zero, then it is likely that the true location is above or below zero as well.</p>
<p>For the Mann-Whitney <span class="math inline">\(U\)</span>-statistic, a similar intuition takes place. Here, all the data are ranked together. If it is the case that the distributions are the same as one another, we should expect that the data will all be mixed in together in terms of ranks. If the distributions differ substantially from one another then there will likely be a biasing of one distribution being more likely to be large or small compared to the other. Reflected in ranks this means that, if the null hypothesis holds, the ranks should be roughly evenly distributed between the two populations and the rank-sums should be approximately equal. Otherwise, we would expect that one of the rank sums would be substantially larger than the other. The <span class="math inline">\(U\)</span>-statistic is then computed simply be shifting the rank sums so that it sits between <span class="math inline">\(0\)</span> and <span class="math inline">\(nm\)</span>. Values near the middle of this range are likely, and occur when the rank-sums are nearly equal.</p>
<p>In this way, whether we are considering a single population or multiple populations, the ranks of the data can be used to connect to the location of those populations.</p>
</section>
<section id="non-parametric-tests-procedures-in-r" class="level2" data-number="17.7">
<h2 data-number="17.7" class="anchored" data-anchor-id="non-parametric-tests-procedures-in-r"><span class="header-section-number">17.7</span> Non-Parametric Tests Procedures in <code>R</code></h2>
<p>In <code>R</code> there is an implementation of both the signed-rank distribution for the signed-rank test and the rank-sum distribution for the <span class="math inline">\(U\)</span>-test. Moreover, both procedures are available through a single function call on data.</p>
<p>The signed-rank distribution is accessible via the <code>{r, p, d, q}signrank</code> calls. These are analogous to the <code>rnorm</code>, <code>pnorm</code>, <code>dnorm</code>, and <code>qnorm</code> calls. An important caveat on the signed-rank distribution in <code>R</code>, however, is that it is computed not for the full signed-rank sum (as presented in this chapter), but instead, for the <em>positive-rank</em> sum. That is, in the test procedures built into <code>R</code>, the relevant test statistic is given by <span class="math display">\[T^{+} = \sum_{i=1}^n \psi(X_i)R_i,\]</span> where <span class="math inline">\(\psi(X_i) = 1\)</span> if <span class="math inline">\(X_i &gt; 0\)</span> and <span class="math inline">\(\psi(X_i) = 0\)</span> otherwise. This positive-rank sum statistic is connected to the signed-rank sum statistic by noting that <span class="math display">\[T = 2T^{+} - \frac{n(n+1)}{2}.\]</span></p>
<p>This presents two important considerations. First, if we wish to compute <span class="math inline">\(P(T \leq t)\)</span> then we can make the translation to using <span class="math display">\[P(T \leq t) = P(2T^{+} - \frac{n(n+1)}{2} \leq t) = P(T^{+} \leq \frac{t}{2} + \frac{n(n+1)}{4}).\]</span> Thus, to directly compute <span class="math inline">\(p\)</span>-values in <code>R</code>, we need to modify the values we are passing to <code>psignrank</code>. Second, if we use the direct test function, the reported statistic will correspond to the positive ranks only. The resulting <span class="math inline">\(p\)</span>-values and conclusions will be equivalent, but it is important to recognize that the output is not identical to what we would compute by hand.</p>
<div id="qwebr-insertion-location-1"></div>
<script type="module">
// Retrieve the insertion point
const currentDocumentLocation = document.getElementById("qwebr-insertion-location-1");

// Initalize an interactive element
const initializedElement =   qwebrCreateInteractiveElement(
    1
  );

// Add the interactive element into the document scope
currentDocumentLocation.appendChild(initializedElement);

// Initialize a Monaco Editor Instance
qwebrCreateMonacoEditorInstance(
  `#########################################
# Signed-Rank Test
###################
# Suppose that we observe T = 8 with n = 30
tstar <- -8/2 + 30*(30 + 1)/4 # Adjust t
psignrank(tstar, n = 30)

# To get the p-value:
2 * psignrank(tstar, n = 30)

########################################
# U-Test
##################
# Suppose that we observe U = 800 with n=50, m=40
pwilcox(800, n = 50, m = 40)

# To get the p-value:
2 * min(pwilcox(800, n=50, m=40), 1 - pwilcox(800, n=50, m=40))

#########################################
# Test Procedures for Observed Data
###################
# We generate random data for X and Y
X <- runif(100,-50, 50)
Y <- rt(200,df=3)
Z <- X + rnorm(100, 0, 1) # Paired with X

# To test individual samples use wilcox.test with only X 
wilcox.test(x = X, alternative = "two.sided", mu = 0)
wilcox.test(x = Y, alternative = "less", mu = 1)
wilcox.test(x = Z, alternative = "greater", mu = -3)

# To test two independent samples, provide X and Y, and 
# specify paired = FALSE
wilcox.test(x = X, y = Y, paired = FALSE)
wilcox.test(x = Y, y = Z, paired = FALSE)

# To test two paired samples, provide X and Y, and 
# specify paired = TRUE
wilcox.test(x = X, y = Z, paired = TRUE)`, 
  1);
</script>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
</section>
<section id="exercises" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="exercises">Exercises</h2>
<div id="exr-17.1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.1</strong></span> For each of the following scenarios, identify what hypothesis test is most appropriate (<span class="math inline">\(Z\)</span>-test, <span class="math inline">\(t\)</span>-test, paired <span class="math inline">\(t\)</span>-test, Wilcoxon signed-rank, Mann-Whitney, or paired signed-rank).</p>
<ol type="a">
<li>A researcher wants to compare the average height of male and female students in a college. They sample a very large number of both male and female students.</li>
<li>A researcher wants to compare the average lifespan of two different breeds of dogs. They sample <span class="math inline">\(23\)</span> dogs of each species, and consider their lifespans.</li>
<li>A market research firm wants to compare customer satisfaction ratings for two competing products. They record satisfaction ratings from a small sample of customers for each product are available.</li>
<li>A teacher wants to determine if the average score on a standardized test for students in their class is significantly different from the national average. Standardized grades are normally distributed, with a known variance.</li>
<li>A company wants to know if a new training program improves employee productivity. They sample productivity scores for <span class="math inline">\(20\)</span> employees both before and after the training program is implemented.</li>
<li>A psychologist wants to investigate if a new therapy reduces anxiety levels in patients. They take a sample of <span class="math inline">\(100\)</span> patients, recording the anxiety levels before and after therapy for each.</li>
<li>A company wants to compare the average salaries of male and female employees with the same job title. They consider the <span class="math inline">\(18\)</span> pairs of male and female employees with the same job title that are available.</li>
<li>A manufacturer claims that their light bulbs last an average of 1000 hours. A consumer group wants to test this claim by taking a sample of <span class="math inline">\(50\)</span> lightbulbs and recording their lifespan.</li>
<li>A psychologist wants to investigate if the average level of anxiety in a specific population is higher than the national average. They record the anxiety scores for <span class="math inline">\(18\)</span> individual patients from the population.</li>
</ol>
</div>
<div id="exr-17.2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.2</strong></span> A local environmental group claims that the median daily water consumption per household in their city exceeds <span class="math inline">\(570\)</span> liters. Daily water consumption (in liters) for a random sample of <span class="math inline">\(7\)</span> households in the city are taken. The researchers observe <span class="math display">\[608, 551, 684, 494, 665, 589, 722.\]</span></p>
<p>Calculate the signed-rank test statistic that researchers can use to test this claim.</p>
</div>
<div id="exr-17.3" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.3</strong></span> A sports coach hypothesizes that the median number of push-ups that their athletes can perform is <span class="math inline">\(50\)</span>. They randomly sample <span class="math inline">\(8\)</span> athletes, and have them do push-ups. The total number performed are: <span class="math display">\[48, 55, 42, 58, 45, 60, 52, 49.\]</span></p>
<ol type="a">
<li>Calculate the signed-rank test statistic that the coach can use to test their claim.</li>
<li>Perform the Wilcoxon signed-rank test. What conclusions can be drawn?</li>
</ol>
</div>
<div id="exr-17.4" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.4</strong></span> A pharmaceutical company claims that their new pain relief medication provides a median pain reduction of at least <span class="math inline">\(3\)</span> points on a 10-point pain scale. They sample <span class="math inline">\(8\)</span> patients, who report the following pain reduction scores after taking the medication <span class="math display">\[2, 4, 5, 2, 4, 1, 3, 2.\]</span></p>
<ol type="a">
<li>What is the signed-rank test statistic, if the average rank procedure is used?</li>
<li>What is the signed-rank test statistic, if the random tie-breaking procedure is used?</li>
</ol>
</div>
<div id="exr-17.5" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.5</strong></span> A researcher is investigating the effectiveness of a new mindfulness technique in reducing stress levels. Changes in stress levels (measured on a standardized scale) for a sample of <span class="math inline">\(10\)</span> participants after a week of practicing the mindfulness technique: <span class="math display">\[-2, 1, 0, -3, 2, 4, -1, 3, 1, -2.\]</span></p>
<ol type="a">
<li>Test the null hypothesis that there is no change in stress levels using mindfulness techniques, using the random tie-breaking procedure.</li>
<li>Repeat part (a) a second time. Do your results change? Explain.</li>
</ol>
</div>
<div id="exr-17.6" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.6</strong></span> A botanist wants to compare the growth of two different varieties of tomato plants. The heights (in inches) of 5 plants from each variety after two weeks are recorded as:</p>
<ul>
<li>Variety A: <span class="math inline">\(3, 5, 4, 6, 10\)</span></li>
<li>Variety B: <span class="math inline">\(7, 8, 6.5, 9, 2\)</span></li>
</ul>
<p>Compute the rank-sum test statistic used to determine whether there is a significant difference between the growth rates of these plants.</p>
</div>
<div id="exr-17.7" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.7</strong></span> A teacher wants to determine if there is a significant difference in the exam scores of students who attended a review session and those who did not. The collect exam scores for 6 students who attended the review and 5 who did not.</p>
<ul>
<li>Attended: <span class="math inline">\(85, 90, 78, 82, 88, 92\)</span></li>
<li>Did Not Attend: <span class="math inline">\(75, 80, 72, 79, 70\)</span></li>
</ul>
<ol type="a">
<li>Compute the rank-sum test statistic used to determine whether there is a significant difference between those who attended and those who did not attend the review session.</li>
<li>What assumptions are required to test this hypothesis using the Mann-Whitney test?</li>
<li>Perform the Mann-Whitney <span class="math inline">\(U\)</span>-test. What conclusions can be drawn?</li>
</ol>
</div>
<div id="exr-17.8" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.8</strong></span> A researcher wants to compare the reaction times of two groups of participants: one group that has been drinking water and another group that has been drinking caffeine. Past research suggests that the distribution of reaction times in the population may change in location under different conditions, but does not change in shape. They record the following reaction times (in ms):</p>
<ul>
<li>Water: <span class="math inline">\(250, 230, 245, 260, 240\)</span></li>
<li>Caffeine: <span class="math inline">\(220, 215, 235, 205, 225\)</span></li>
</ul>
<ol type="a">
<li>What is required in order to test the null hypothesis that the locations of the two distributions are equivalent?</li>
<li>Test the hypothesis that the locations of the two distributions are equivalent.</li>
</ol>
</div>
<div id="exr-17.9" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.9</strong></span> A doctor wants to compare the effectiveness of two different pain relievers in reducing headache pain. They record the following data on random patients reporting a pain intensity score (scale of <span class="math inline">\(1\)</span> to <span class="math inline">\(10\)</span>):</p>
<ul>
<li>Medication A: <span class="math inline">\(2, 3, 1, 4, 2, 3\)</span></li>
<li>Medication B: <span class="math inline">\(1, 0, 2, 1\)</span></li>
</ul>
<ol type="a">
<li>Suppose that a Mann-Whitney <span class="math inline">\(U\)</span>-test is run on these data. What is required of the data to run the test, and what is the hypothesis that is actually being tested?</li>
<li>Run the Mann-Whitney <span class="math inline">\(U\)</span>-test, and draw relevant conclusions.</li>
</ol>
</div>
<div id="exr-17.10" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.10</strong></span> An educator wants to compare the reading speeds of students who undergo a speed-reading program. A group of <span class="math inline">\(5\)</span> students attend the program, and their reading speeds before and after the program are recorded (in words per minute):</p>
<ul>
<li>After program: <span class="math inline">\(250, 280, 262, 275, 240\)</span></li>
<li>Before Program: <span class="math inline">\(200, 220, 210, 230, 215\)</span></li>
</ul>
<ol type="a">
<li>What is the signed-rank test statistic used to test if the program increases the median reading speed for children?</li>
<li>What is the signed-rank test statistic used to test if the program increases the median reading speed for children, by at least <span class="math inline">\(50\)</span> words per minute?</li>
</ol>
</div>
<div id="exr-17.11" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.11</strong></span> A therapist wants to assess the effectiveness of a new therapy for depression. They record the depressive scores (on a standardized scale) for <span class="math inline">\(4\)</span> patients before and after therapy. The results are:</p>
<ul>
<li>Patient 1: Before: <span class="math inline">\(30\)</span>, After: <span class="math inline">\(25\)</span></li>
<li>Patient 2: Before: <span class="math inline">\(28\)</span>, After: <span class="math inline">\(22\)</span></li>
<li>Patient 3: Before: <span class="math inline">\(32\)</span>, After: <span class="math inline">\(28\)</span></li>
<li>Patient 4: Before: <span class="math inline">\(21\)</span>, After: <span class="math inline">\(20\)</span></li>
</ul>
<ol type="a">
<li>Test the null hypothesis that therapy changes depressive scores in this population. Indicate what hypothesis test is used, and what needs to be assumed about the populations to use it.</li>
<li>Test the null hypothesis that therapy changes depressive scores, reducing them by <span class="math inline">\(3\)</span>, in this population. Indicate what hypothesis test is used, and what needs to be assumed about the populations to use it.</li>
</ol>
</div>
<div id="exr-17.12" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.12</strong></span> A doctor wants to assess the effectiveness of a new medication in lowering blood pressure. Blood pressure readings (systolic) for 7 patients before and after taking the medication are given as:</p>
<ul>
<li>Patient 1: Before: <span class="math inline">\(140\)</span>, After: <span class="math inline">\(135\)</span></li>
<li>Patient 2: Before: <span class="math inline">\(150\)</span>, After: <span class="math inline">\(145\)</span></li>
<li>Patient 3: Before: <span class="math inline">\(138\)</span>, After: <span class="math inline">\(130\)</span></li>
<li>Patient 4: Before: <span class="math inline">\(135\)</span>, After: <span class="math inline">\(138\)</span></li>
<li>Patient 5: Before: <span class="math inline">\(155\)</span>, After: <span class="math inline">\(150\)</span></li>
<li>Patient 6: Before: <span class="math inline">\(148\)</span>, After: <span class="math inline">\(142\)</span></li>
<li>Patient 7: Before: <span class="math inline">\(148\)</span>, After: <span class="math inline">\(153\)</span></li>
</ul>
<ol type="a">
<li>What is the relevant signed-rank test statistic if using the average-rank procedure?</li>
<li>What is the relevant signed-rank test statistic if using the random tie-breaking procedure?</li>
</ol>
</div>
<div id="exr-17.13" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.13</strong></span> A researcher wants to evaluate the effectiveness of a new sleep aid. They collect data on <span class="math inline">\(5\)</span> patients, before and after using the sleep aid. The quality scores (on a scale of <span class="math inline">\(1\)</span> to <span class="math inline">\(10\)</span>) for each of the participants are recorded as follows:</p>
<ul>
<li>Participant 1: Before: <span class="math inline">\(2\)</span>, After: <span class="math inline">\(7\)</span></li>
<li>Participant 2: Before: <span class="math inline">\(3\)</span>, After: <span class="math inline">\(6\)</span></li>
<li>Participant 3: Before: <span class="math inline">\(5\)</span>, After: <span class="math inline">\(3\)</span></li>
<li>Participant 4: Before: <span class="math inline">\(2\)</span>, After: <span class="math inline">\(4\)</span></li>
<li>Participant 5: Before: <span class="math inline">\(6\)</span>, After: <span class="math inline">\(1\)</span></li>
</ul>
<ol type="a">
<li>Using the random tie-breaking procedure, assess whether there is a change in sleep quality observed by taking the sleep aid.</li>
<li>Repeat the procedure in part (a). Are your results the same or different?</li>
</ol>
</div>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>For instance, that it follows a normal distribution, a binomial distribution, or similar.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn2"><p>If it exists.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn3"><p>Or, the one-tailed equivalents.<a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn4"><p>Specifically, it is possible that the average rank procedure rejects the null hypothesis in the one tail test, concluding (for instance) that <span class="math inline">\(\mu &gt; 0\)</span>. However, using the same data, if you add some amount to the tied data points, making them more positive, then the null hypothesis may not be rejected any longer. These two conclusions are incompatible with one another, and arise as a natural consequence of the average rank procedure.<a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn5"><p>Very likely.<a href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn6"><p>In the case of <span class="math inline">\(Z\)</span>-tests, <span class="math inline">\(t\)</span>-tests, and the presented version of the signed-rank test, the null distribution has always been symmetric around <span class="math inline">\(0\)</span>. In this case we must have that <span class="math inline">\(F(-|t|) = 1-F(|t|)\)</span> and as such, we can express the <span class="math inline">\(p\)</span>-value as the sum of the two tails. For non-symmetric null distributions, we still wish to understand the probability of observing something at least as extreme as what was actually observed. Here, however, that is not as simple as saying less than <span class="math inline">\(-|t|\)</span> or above <span class="math inline">\(|t|\)</span>, since the distribution is not centered on <span class="math inline">\(0\)</span>. In fact, in the case of the <span class="math inline">\(U\)</span>-statistic, the null distribution is strictly positive. This form, <span class="math inline">\(2\times\min\{F(u), 1-F(u)\}\)</span> is broadly applicable across many hypothesis tests, however, it tends to be less informative compared to the sum of the tail probabilities.<a href="#fnref6" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn7"><p>Note that here, consistency refers to a specific statistical idea. Namely, consistency represents the idea that, as sample sizes increase larger and larger, the resulting statistical procedure will approach the correct results.<a href="#fnref7" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn8"><p>For instance, the Kolmogorov-Smirnov test is a nonparametric test that considers the equality (or lack thereof) of continuous distributions, without making the same assumptions under the null hypothesis.<a href="#fnref8" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn9"><p>Under somewhat rigorous assumptions<a href="#fnref9" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn10"><p>This procedure is analogous to the <span class="math inline">\(t\)</span>-test for paired data. In the <span class="math inline">\(t\)</span>-test for paired data we first consider the single sample that arises from differencing the observations. Then, a single sample <span class="math inline">\(t\)</span>-test is conducted on the sample of paired differences. To do so nonparametrically, we first consider the single sample of paired differences, and then conduct a Wilcoxon signed-rank test on this sample of paired differences.<a href="#fnref10" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script>

/* definition of content for the buttons */
const webex_buttons = {check_hidden:          "<b>&check;</b>",
                       check_hidden_alt:      "Check answer",
                       check_shown:           "<b>&lsh;</b>",
                       check_shown_alt:       "Hide check",
                       check_of_total:        "/",
                       solution:              "<b>&quest;</b>",
                       solution_alt:          "Correct solution",
                       question_next:         "<b>&#8634;</b>",
                       question_next_alt:     "Next question",
                       question_previous:     "",
                       question_previous_alt: ""}

/* update total correct if #webex-total_correct exists */
update_total_correct = function() {
  console.log("webex: update total_correct");

  document.querySelectorAll(".webex-total_correct").forEach(total => {
    p = total.closest(".webex-box");
    var correct = p.getElementsByClassName("webex-correct").length;
    var solvemes = p.getElementsByClassName("webex-solveme").length;
    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;
    var selects = p.getElementsByClassName("webex-select").length;
    /* no specific class on input node, thus searching via query selector */
    var checkboxgroups = p.querySelectorAll("div[class=webex-checkboxgroup] input[type=checkbox]").length

    /* show number of correct / total number of answers */
    total.innerHTML = correct + "&nbsp;" + webex_buttons.check_of_total + "&nbsp;" + (solvemes + radiogroups + checkboxgroups + selects);
  });
}

/* check answers */
check_func = function() {
  console.log("webex: check answer");

  //var cl = this.parentElement.classList;
  var cl = this.closest(".webex-box").classList;
  if (cl.contains("unchecked")) {
    cl.remove("unchecked");
    this.innerHTML = webex_buttons.check_shown; //"Hide check";
    if (webex_buttons.check_shown_alt.length > 0) this.setAttribute("title", webex_buttons.check_shown_alt);
  } else {
    cl.add("unchecked");
    this.innerHTML = webex_buttons.check_hidden; //"Check answer";
    if (webex_buttons.check_hidden_alt.length > 0) this.setAttribute("title", webex_buttons.check_hidden_alt);
  }
}

/* Show/hide correct solution */
solution_func = function() {
  console.log("webex: show/hide solution");

  var div = this.closest(".webex-question").querySelector(".webex-solution");
  var cl = div.classList;

  if (cl.contains("visible")) {
    cl.remove("visible");
  } else {
    cl.add("visible");
  }
}

/* function to check if the real answer is numeric */
convert_to_numeric = function(x) {
    if (typeof x == "string") {
        /* do nothing */
    } else if (x.length == 1) {
        /* take first element */
        x = x[0]
    } else {
        return NaN;
    }

    /* remove spaces for easier parsing */
    x = x.replace(/\s/g, "");

    /* Define patterns for different formats, note that spaces have been removed above */
    const patterns = [
        {regex: /^[+-]?\d+(\.\d{3})*,\d+$/, decimal: ",", thousand: "." },  // Format: "1.100.100.100,3"
        {regex: /^[+-]?\d+(,\d{3})*\.\d+$/, decimal: ".", thousand: "," },  // Format: "1,100,100,100.3"
        {regex: /^[+-]?\d+(\.\d+)?$/, decimal: "." },                       // Format: "1100100100.5"
        {regex: /^[+-]?\d+,\d+$/, decimal: "," }                            // Format: "1100100100,5"
    ];

    /* testing all regular expressions, convert to float if possible */
    for (const { regex, decimal, thousand } of patterns) {
        if (regex.test(x)) {
            let numeric = x;
            if (thousand) numeric = numeric.replace(new RegExp(`\\${thousand}`, "g"), "");
            numeric = numeric.replace(decimal, ".");
            return parseFloat(numeric);
        }
    }
    
    /* input of length 1 but none of the known formats, return NaN */
    return NaN;
}

/* function for checking solveme answers */
solveme_func = function(e) {
  /* avoid that keyup and keychange twice execute this function within nms = 10
   * ms, clearing inputTimer and add timeout */
  console.log("webex: check solveme");

  /* float, precision for checking numeric answers */
  const eps = 0.00000000000001;

  /* get last checked user answer */
  const question = this.closest(".webex-question")

  /* extracting classes */
  var cl = this.classList;
  var my_answer = this.value;

  /* empty answer? Job done */
  if (my_answer == "") {
    cl.remove("webex-correct");
    cl.remove("webex-incorrect");
    return false;
  }

  /* "Else" we continue evaluating the answer */
  var real_answers = JSON.parse(this.dataset.answer);

  /* by default we assume the users' answer is incorrect */
  var user_answer_correct = false;

  /* check if the correct answer is numeric, i.e. if 
   * real_answers is of length 1 containing one single numeric
   * value in a known format, else, NaN is returned */
  const num_real_answer = convert_to_numeric(real_answers);
  const num_my_answer   = convert_to_numeric(my_answer);

  /* if the correct answer is numeric (float), the user's answer
   * must also be numeric. If not, it is wrong. Else we can
   * compare floating point numbers */
  if (!isNaN(num_real_answer) && !isNaN(num_my_answer)) {
    //DEV// console.log("webex: evaluating numeric answer")
    /* check if the real answer and the user input are numerically the same;
     * adding 'delta' to avoid precision issues */
    var diff = Math.abs(num_real_answer - num_my_answer);
    if (diff < parseFloat(this.dataset.tol) + eps) { user_answer_correct = true; }

  /* if the question contains regex, a regular expression is used
   * to evaluate the users answer (only possible if length of answers is 1) */
  } else if (cl.contains("regex") && real_answers.length == 1) {
    //console.log("webex: evaluating answer using regular expression")
    let regex = new RegExp(real_answers[0], cl.contains("ignorecase") ? "i" : "");
    if (regex.test(my_answer)) { user_answer_correct = true; }

  /* else we evaluate on 'string level', considering the creators preferences
   * regarding set options */
  } else {
    //console.log("webex: evaluating string answer")
    /* modify/prepare answer */
    if (cl.contains("ignorecase")) { my_answer = my_answer.toLowerCase(); }
    if (cl.contains("nospaces"))   { my_answer = my_answer.replace(/ /g, ""); }

    /* if the real answer includes user input - correct */
    if (real_answers.includes(my_answer)) {
      user_answer_correct = true;
  
      // added regex bit
      if (cl.contains("regex")) {
        answer_regex = RegExp(real_answers.join("|"))
        if (answer_regex.test(my_answer)) {
          cl.add("webex-correct");
        }
      }
    }
  }

  if (user_answer_correct) {
      cl.add("webex-correct");
      cl.remove("webex-incorrect");
  } else {
      cl.add("webex-incorrect");
      cl.remove("webex-correct");
  }

  update_total_correct();

}

/* function for checking select answers */
select_func = function(e) {
  console.log("webex: check select");

  var cl = this.classList

  /* add style */
  cl.remove("webex-incorrect");
  cl.remove("webex-correct");
  if (this.value == "answer") {
    cl.add("webex-correct");
  } else if (this.value != "blank") {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}

/* function for checking radiogroups answers */
radiogroups_func = function(e) {
  console.log("webex: check radiogroups");

  var checked_button = document.querySelector("input[name=" + this.id + "]:checked");
  var cl = checked_button.parentElement.classList;
  var labels = checked_button.parentElement.parentElement.children;

  /* get rid of styles */
  for (i = 0; i < labels.length; i++) {
    labels[i].classList.remove("webex-incorrect");
    labels[i].classList.remove("webex-correct");
  }

  /* add style */
  if (checked_button.value == "answer") {
    cl.add("webex-correct");
  } else {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}


/* function for checking checkboxgroups answers */
checkboxgroups_func = function(e) {
  console.log("webex: check checkboxgroups");

  /* list of all answer elements (correct and incorrect) */
  var inputs = document.querySelectorAll("div[id='" + this.id + "'] input")

  /* setting class for correct/incorrect answers */
  inputs.forEach(function(input) {
      var label = input.parentNode
      if ((input.checked && input.value == "answer") || (!input.checked && input.value == "")) {
          //input.setAttribute("class", "webex-correct")
          label.setAttribute("class", "webex-correct")
      } else {
          label.setAttribute("class", "webex-incorrect")
      }
  });

  update_total_correct();
}

/* shuffling array (thanks to stack overflow)
 * If argument x is an integer we create an integer sequence
 * from 0, 1, ..., (x - 1) and return a shuffled version. If
 * the input is an array, we simply shuffle it */
shuffle_array = function(x) {
   if (Number.isInteger(x) && !isNaN(x)) {
     x = Array.from({length: x}, (v, i) => i);
   }
   let shuffled = x.map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort).map(({ value }) => value)
   return shuffled;
}

/* ---------------------------------------------------------
 * ---------------------------------------------------------
 * --------------------------------------------------------- */
window.onload = function() {
  console.log("webex onload");

  /* setting up buttons and actions to show/hide answers */
  document.querySelectorAll(".webex-check").forEach(section => {
    section.classList.add("unchecked");

    /* ul to take up the list items with buttons */
    let button_ul = document.createElement("ul");
    button_ul.setAttribute("class", "webex-button-list");
    section.appendChild(button_ul);

    /* button to _check_ if answers given are correct */
    let li_check = document.createElement("li");
    button_ul.appendChild(li_check); /* add list item to ul */
    let btn_check = document.createElement("button");
    btn_check.innerHTML = webex_buttons.check_hidden;  // "Check answer";
    btn_check.setAttribute("class", "webex-button webex-button-check");
    if (webex_buttons.check_hidden_alt.length > 0) btn_check.setAttribute("title", webex_buttons.check_hidden_alt);
    btn_check.onclick = check_func;
    li_check.appendChild(btn_check);

    /* span to show current number of points (when _check_ active) */
    let spn = document.createElement("span");
    spn.classList.add("webex-total_correct");
    li_check.appendChild(spn);

    /* button to show the _solution_ if there is one */
    var has_solution = section.parentNode.querySelectorAll(".webex-solution").length > 0;
    if (has_solution) {
      let li_solution = document.createElement("li");
      button_ul.appendChild(li_solution); /* add list item to ul */
      let btn_solution = document.createElement("button");
      btn_solution.innerHTML = webex_buttons.solution; // "Correct answer";
      btn_solution.setAttribute("class", "webex-button webex-button-solution");
      if (webex_buttons.solution_alt.length > 0) btn_solution.setAttribute("title", webex_buttons.solution_alt);
      btn_solution.onclick = solution_func;
      li_solution.appendChild(btn_solution);
    }

  });

  /* set up webex-solveme inputs */
  document.querySelectorAll(".webex-solveme").forEach(solveme => {
    solveme.setAttribute("autocomplete","off");
    solveme.setAttribute("autocorrect", "off");
    solveme.setAttribute("autocapitalize", "off");
    solveme.setAttribute("spellcheck", "false");
    solveme.value = "";

    /* adjust answer for ignorecase or nospaces */
    if (solveme.classList.contains("ignorecase")) {
      solveme.dataset.answer = solveme.dataset.answer.toLowerCase();
    }
    /* adjust answer for 'no spaces' (ignore spaces) */
    if (solveme.classList.contains("nospaces")) {
      solveme.dataset.answer = solveme.dataset.answer.replace(/ /g, "");
    }

    /* attach checking function, triggered on key up, change, and when
     * elemnt is out of focus. Only evaluated once by tracking changes
     * via variable solveme_last_user_answer */
    solveme.addEventListener("keyup",  solveme_func);
    solveme.addEventListener("change", solveme_func);
    solveme.addEventListener("blur",   solveme_func);

    /* adding span to show correct/incorrect icon */
    solveme.insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")
  });

  /* set up radiogroups (single choice questions with display = "buttons") */
  document.querySelectorAll(".webex-radiogroup").forEach(radiogroup => {
    radiogroup.onchange = radiogroups_func;
  });

  /* set up checkboxgroups (multiple choice questions with display = "buttons") */
  document.querySelectorAll(".webex-checkboxgroup").forEach(checkboxgroup => {
    checkboxgroup.onchange = checkboxgroups_func;
  });

  /* set up selects (dropdown menus) */
  document.querySelectorAll(".webex-select").forEach(select => {
    select.onchange = select_func;
    /* append webex-icon for correct/incorrect icons */
    var elem = document.createElement("span")
    elem.classList.add("webex-icon")
    select.parentNode.appendChild(elem)
  });

  /* change to next/previous question if multiple are available */
  function handleQuestionClick(group, questions, step) {
    return async function() {
      /* get question order as integer vector */
      let questionOrder = group.dataset.questionOrder.split(",").map(str => parseInt(str));

      /* current question/position */
      let currentPosition = parseInt(group.dataset.currentPosition);
  
      /* Hide the current question */
      questions.forEach(question => { question.classList.remove("active"); });

      /* Move to the next question index */
      currentPosition = (currentPosition + step) % questionOrder.length;
      if (currentPosition < 0) currentPosition = currentPosition + questionOrder.length

      /* Display the new question */
      // devel // console.log("set question " + questionOrder[currentPosition] +
      // devel //             " (" + currentPosition + ") as active");
      questions[questionOrder[currentPosition]].classList.add("active");
  
      // Update the currentPosition data attribute on the group div
      group.dataset.currentPosition = currentPosition;
    };
  }

  
  document.querySelectorAll(".webex-group").forEach(group => {
    const questions = Array.from(group.querySelectorAll(".webex-question"));
    const questionOrder = shuffle_array(questions.length);

    /* take start position (if set) or start at 0 */
    const currentPosition = parseInt(group.getAttribute("data-start-position")) || 0;

    /* show the default question for each group */
    questions[questionOrder[currentPosition]].classList.add("active");
    // devel // console.log("set question " + questionOrder[currentPosition] +
    // devel //             " (" + currentPosition + ") as active; " + questionOrder);
  
    /* store random order of questions as well as current position */
    group.dataset.questionOrder   = questionOrder;
    group.dataset.currentPosition = currentPosition;

    /* find all webex-questions, search for .webex-button-list and
     * populate the list with necessary <li><button>...</button></li> elements */
    questions.forEach(question => {
        let button_ul = question.querySelector("ul.webex-button-list");

        let li_next = document.createElement("li");
        let nextButton = document.createElement("button");
        nextButton.setAttribute("class", "webex-button webex-button-next");
        if (webex_buttons.question_next_alt.length > 0) nextButton.setAttribute("title", webex_buttons.question_next_alt);
        nextButton.innerHTML = webex_buttons.question_next; // "Next question";
        nextButton.addEventListener("click", handleQuestionClick(group, questions, 1));
        li_next.appendChild(nextButton);

        let li_previous = document.createElement("li");
        let previousButton = document.createElement("button");
        previousButton.setAttribute("class", "webex-button webex-button-previous");
        if (webex_buttons.question_previous_alt.length > 0) previousButton.setAttribute("title", webex_buttons.question_previous_alt);
        previousButton.innerHTML = webex_buttons.question_previous; // "Previous question";
        previousButton.addEventListener("click", handleQuestionClick(group, questions, -1));
        li_previous.appendChild(previousButton);

        console.log(button_ul);
        if (webex_buttons.question_previous.length > 0) button_ul.appendChild(li_previous);
        if (webex_buttons.question_next.length > 0) button_ul.appendChild(li_next);
    });
  });


  update_total_correct();
}

</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          trigger: 'click',
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          positionFixed: true,
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../notes/chapter16.html" class="pagination-link" aria-label="Hypothesis Testing and Confidence Intervals in Two Populations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Hypothesis Testing and Confidence Intervals in Two Populations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../notes/chapter18.html" class="pagination-link" aria-label="The Analysis of Categorical Data">
        <span class="nav-page-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">The Analysis of Categorical Data</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>